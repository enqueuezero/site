(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{510:function(e,t,n){"use strict";n.r(t);var s=n(54),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"the-queues-of-io-uring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-queues-of-io-uring"}},[e._v("#")]),e._v(" The Queues of io_uring")]),e._v(" "),n("p",[e._v("io_uring is asynchronous I/O programming for Linux. Traditionally, we do async via select, poll, epoll, ugly aio, etc. However, they're meant for sockets and pipes. For high performant applications, since Kernel 5.6, when even file I/O becomes the bottleneck, io_uring is a better solution. io_uring provides a general interface handling both sockets and regular files.")]),e._v(" "),n("p",[e._v("Fundamentally, io_uring is about operating two ring buffers,")]),e._v(" "),n("ul",[n("li",[e._v("Submission Queue (SQ)")]),e._v(" "),n("li",[e._v("Completion Queue (CQ)")])]),e._v(" "),n("p",[e._v("These two ring buffers are shared between the kernel and user space, so the data transfering between the kernal and user space is a zero-copy.")]),e._v(" "),n("p",[e._v("Having that in mind, let's see how io_uring works.")]),e._v(" "),n("p",[n("img",{attrs:{src:"/static/images/io_uring-queues.svg",alt:""}})]),e._v(" "),n("ol",[n("li",[e._v("Your program sets up two ring buffers at first.")]),e._v(" "),n("li",[e._v("Enqueue Submission Queue Entry (SQE) to SQ.")]),e._v(" "),n("li",[e._v("Kernal consumes SQEs and puts Completion Queue Events (CQE) to CQ.")]),e._v(" "),n("li",[e._v("Your program consumes CQEs.")])])])}),[],!1,null,null,null);t.default=i.exports}}]);