(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{477:function(e,t,r){"use strict";r.r(t);var s=r(54),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"coroutine"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#coroutine"}},[e._v("#")]),e._v(" Coroutine")]),e._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#context"}},[e._v("Context")])]),r("li",[r("a",{attrs:{href:"#overview"}},[e._v("Overview")])]),r("li",[r("a",{attrs:{href:"#patterns"}},[e._v("Patterns")]),r("ul",[r("li",[r("a",{attrs:{href:"#non-preemptive-multi-tasking-system"}},[e._v("Non-preemptive multi-tasking system")])]),r("li",[r("a",{attrs:{href:"#yield-resume"}},[e._v("Yield / Resume")])]),r("li",[r("a",{attrs:{href:"#symmetric-coroutines-v-s-asymmetric-coroutines"}},[e._v("Symmetric Coroutines v/s Asymmetric Coroutines")])])])]),r("li",[r("a",{attrs:{href:"#solutions"}},[e._v("Solutions")]),r("ul",[r("li",[r("a",{attrs:{href:"#lua"}},[e._v("Lua")])]),r("li",[r("a",{attrs:{href:"#python"}},[e._v("Python")])]),r("li",[r("a",{attrs:{href:"#ruby"}},[e._v("Ruby")])])])]),r("li",[r("a",{attrs:{href:"#conclusions"}},[e._v("Conclusions")])]),r("li",[r("a",{attrs:{href:"#references"}},[e._v("References")])])])]),r("p"),e._v(" "),r("h2",{attrs:{id:"context"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#context"}},[e._v("#")]),e._v(" Context")]),e._v(" "),r("p",[e._v("Although thread is much more lightweight than process, people still think it's too heavy. In Linux kernel,  creating a thread still need to assign same amount of memory like process. Therefore, a more lightweight solution needs to reduce memory usage.")]),e._v(" "),r("p",[e._v("Micro-threads, or usually named as coroutine, is such kind of technology.")]),e._v(" "),r("h2",{attrs:{id:"overview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),r("p",[e._v("Coroutines, or cooperative routines, are routines running in non-preemptive multitasking system. In human word, coroutines are just special functions. We can temporarily suspend running a coroutine function. And when we resume the function, it continues running.")]),e._v(" "),r("p",[e._v("Basically the code can be paused and resumed, pretty much like threads, except that it's not VM or OS scheduling coroutines. Programmer needs to make sure a coroutine must never preempted.")]),e._v(" "),r("p",[e._v("Coroutines can be used to implement cooperative tasks, event loop, generators, lazy evaluation.")]),e._v(" "),r("p",[e._v("Check below code and running sequence in Lua:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("co = coroutine.create(function () \n  for i = 1, 10 do\n    print(i)\n    coroutine.yield()\n  end\nend)\n\ncoroutine.resume(co) # --\x3e 1\ncoroutine.resume(co) # --\x3e 2\ncoroutine.resume(co) # --\x3e 3\ncoroutine.resume(co) # --\x3e 4\ncoroutine.resume(co) # --\x3e 5\ncoroutine.resume(co) # --\x3e 6\ncoroutine.resume(co) # --\x3e 7\ncoroutine.resume(co) # --\x3e 8\ncoroutine.resume(co) # --\x3e 9\ncoroutine.resume(co) # --\x3e 10\n")])])]),r("ul",[r("li",[r("code",[e._v("coroutine.create")]),e._v(" create a new coroutine.")]),e._v(" "),r("li",[r("code",[e._v("coroutine.yield")]),e._v(" suspend coroutine from running.")]),e._v(" "),r("li",[r("code",[e._v("coroutine.resume")]),e._v(" resume running coroutine.")])]),e._v(" "),r("p",[e._v("In this example, the first time we call "),r("code",[e._v("coroutine.resume(co)")]),e._v(" starts its execution and runs until the first yield. For the rest of calls they basically do the same thing until the final one.")]),e._v(" "),r("h2",{attrs:{id:"patterns"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#patterns"}},[e._v("#")]),e._v(" Patterns")]),e._v(" "),r("h3",{attrs:{id:"non-preemptive-multi-tasking-system"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#non-preemptive-multi-tasking-system"}},[e._v("#")]),e._v(" Non-preemptive multi-tasking system")]),e._v(" "),r("p",[e._v("Preemptive means we don't care how to schedule when to run which thread or process. In non-preemptive multi-tasking system, it's programmers' responsibility to tell VM when to suspend coroutine and when to resume.")]),e._v(" "),r("h3",{attrs:{id:"yield-resume"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#yield-resume"}},[e._v("#")]),e._v(" Yield / Resume")]),e._v(" "),r("p",[e._v('Yield is very intuitive - a coroutine tells to the system "hey I\'m gonna yield for now" and the system simply suspend it.')]),e._v(" "),r("p",[e._v("Resume is similar - when someone calls resume, the system rerun the coroutine until it's completed or another yielding.")]),e._v(" "),r("p",[e._v("In previous example, lua has "),r("code",[e._v("coroutine.yield()")]),e._v(" and "),r("code",[e._v("coroutine_object.resume()")]),e._v(" for the two interfaces.")]),e._v(" "),r("h3",{attrs:{id:"symmetric-coroutines-v-s-asymmetric-coroutines"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#symmetric-coroutines-v-s-asymmetric-coroutines"}},[e._v("#")]),e._v(" Symmetric Coroutines v/s Asymmetric Coroutines")]),e._v(" "),r("ul",[r("li",[e._v("Asymmetric coroutines\n"),r("ul",[r("li",[e._v("Needs a function to suspend itself.")]),e._v(" "),r("li",[e._v("Needs a function to resume coroutine.")])])]),e._v(" "),r("li",[e._v("Symmetric coroutines\n"),r("ul",[r("li",[e._v("Needs a function to transfer control to other coroutines.")])])])]),e._v(" "),r("p",[e._v("Symmetric coroutines introduce less code. It can build on top of asymmetric coroutines: each transfer is equal to a yield followed by a resume.")]),e._v(" "),r("h2",{attrs:{id:"solutions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#solutions"}},[e._v("#")]),e._v(" Solutions")]),e._v(" "),r("h3",{attrs:{id:"lua"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lua"}},[e._v("#")]),e._v(" Lua")]),e._v(" "),r("p",[e._v("Lua has builtin coroutine support.")]),e._v(" "),r("p",[e._v("You can create coroutine like this:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('co = coroutine.create(function()\n    print("hi")\nend\n')])])]),r("p",[e._v("Any coroutine is in one of three states: suspended, running, and dead. You can check status by "),r("code",[e._v("coroutine.status(co)")]),e._v(".")]),e._v(" "),r("p",[e._v("To start or restart the execution of a coroutine, run "),r("code",[e._v("coroutine.resume(co)")]),e._v(".")]),e._v(" "),r("h3",{attrs:{id:"python"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[e._v("#")]),e._v(" Python")]),e._v(" "),r("p",[e._v("Coroutines in Python are mainly used in async. You can create a coroutine like this:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('async def co():\n    print("hi")\n')])])]),r("p",[e._v("Python uses symmetric coroutine, so you don't need to worry about resume, just need to TRANSFER control to another coroutine:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('async def compute(x, y):\n    return x + y\n\nasync def co():\n    result = await compute(0, 42)\n    print("%d + %d = %d", (0, 42, result))\n\nimport asyncio\nasyncio.get_event_loop().run_until_complte(co())\n')])])]),r("h3",{attrs:{id:"ruby"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ruby"}},[e._v("#")]),e._v(" Ruby")]),e._v(" "),r("p",[e._v("Fibers are coroutine equivalent in Ruby. You can create Fiber like below code:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("fiber = Fiber.new do\n  Fiber.yield 1\nend\n\nputs fiber.resume\n")])])]),r("p",[e._v("Fiber also support transferring control. The API allows you resume another fiber from where it last stopped or start it if it was not resumed before:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('f1 = Fiber.new do\n  puts "f1"\n  Fiber.yield\nend\n\nf2 = Fiber.new do\n  puts "start"\n  f1.transfer\nend\n\nf2.resume\n')])])]),r("h2",{attrs:{id:"conclusions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#conclusions"}},[e._v("#")]),e._v(" Conclusions")]),e._v(" "),r("p",[e._v("Coroutines implement multi-tasking by consuming less resource. The downside is that it introduces yield / resume into your code. If thread or process cannot meet your multi-tasking requirements, try coroutine, although it also means rewrite you application very likely.")]),e._v(" "),r("h2",{attrs:{id:"references"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://www.lua.org/pil/9.1.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Lua - Coroutine Basics"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://docs.python.org/3/library/asyncio-task.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Python - Tasks and coroutines"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://ruby-doc.org/core-2.1.1/Fiber.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ruby - Fiber"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);