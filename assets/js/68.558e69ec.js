(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{455:function(e,a,t){"use strict";t.r(a);var s=t(54),n=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"sstable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sstable"}},[e._v("#")]),e._v(" SSTable")]),e._v(" "),t("p",[e._v("SSTable stands for Sorted Strings Table; it's a file of key-value pairs sorted by keys. Keys and values are artitrary byte strings. By design, the keys and values are immutable. Several database engines are built on top of SSTable, such as LevelDB, RocksDB, Cassandra, Lucene, InfluxDB, etc.")]),e._v(" "),t("p",[e._v("An SSTable-based database consists of a sequence of SSTable files. Each unique key only appears once in an SSTable file. If the key appears in several SSTable files, the value in the last seen file is used. Several SSTable files can be merged and compacted into one single SSTable file periodically. Old key-value pairs are discarded on the merging operation.")]),e._v(" "),t("p",[e._v("Finding a particular key in an SSTable file is simply to perform a binary search since all keys are ordered. Each SSTable file has typically a few kilotytes and thus searching is pretty fast.")]),e._v(" "),t("p",[e._v("Because of immutable, any update will need to append the new key-value pair to the SSTable file. What if there are two updates on the same key in a short period? We already know that each key can only appear once in a file. The solution is by maintaining an in-memory balanced tree data structure; such a tree is called "),t("em",[e._v("memtable")]),e._v(". When the size of the memtable is over the threshold, all sorted keys are then dumped to an SSTable file. Meanwhile, such a file becomes the latest segment of the database. Finding a particular key then becomes a two-steps: find in-memory first; if not found, find on-disk. As time passed by, old SSTable files are somehow aggregated by a merging process.")]),e._v(" "),t("p",[e._v("Yet such a solution leaves one problem to us, what if the database crashes before dumping the latest key-value pairs to the disk? One commonly used solution is by introducing binlog. The keys in the binlog file are not sorted, but it doesn't matter; they're only used to recover from a crash. The binlog file can be discarded when all data have been written to the disk.")]),e._v(" "),t("hr"),e._v(" "),t("p",[t("strong",[e._v("Case Study: RocksDB.")]),e._v(" Let's see how RocksDB builds up from this simple data structure. "),t("a",{attrs:{href:"https://github.com/facebook/rocksdb/wiki/RocksDB-Basics",target:"_blank",rel:"noopener noreferrer"}},[e._v("1"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("There are three basic constructs in RocksDB, "),t("em",[e._v("memtable")]),e._v(", "),t("em",[e._v("sstfile")]),e._v(", and "),t("em",[e._v("logfile")]),e._v(". The "),t("em",[e._v("memtable")]),e._v(" tracks the recent updates in memory. Each update is sequentially written to a "),t("em",[e._v("logfile")]),e._v(" on storage. When the size of "),t("em",[e._v("memtable")]),e._v(" is over a threshold, it's flushed to a "),t("em",[e._v("sstfile")]),e._v(" on storage, and the "),t("em",[e._v("logfile")]),e._v(" is discarded correspondingly.")]),e._v(" "),t("p",[e._v("On top of these constructs, RocksDB provides some simple operators: "),t("code",[e._v("Get(key)")]),e._v(", "),t("code",[e._v("MultiGet(keys)")]),e._v(", "),t("code",[e._v("Put(key, value)")]),e._v(", "),t("code",[e._v("Delete(key)")]),e._v(", "),t("code",[e._v("NewIterator()")]),e._v(", etc.")]),e._v(" "),t("p",[e._v("In-between the APIs and the underlying files, there are several aspects being introduced, such as data compression, checksuming, snapshot, replication, read-only mode, transactions, and multi-threading, etc.")])])}),[],!1,null,null,null);a.default=n.exports}}]);